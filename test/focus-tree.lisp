(in-package #:org.shirakumo.alloy.test)

(defclass named-focus-list (alloy:focus-list)
  ((name :initarg :name :reader name)))

(defmethod print-object ((focus-list named-focus-list) stream)
  (print-unreadable-object (focus-list stream)
    (format stream "~a ~a" (name focus-list) (alloy:focus focus-list))))

(defun find-child-with (focus element)
  (if (eql focus (alloy:focus element))
      element
      (alloy:do-elements (child element)
        (let ((found (find-child-with focus child)))
          (when found (return found))))))

(defun check-focus-invariant (tree element)
  (ecase (alloy:focus element)
    (:strong
     (unless (eql element (alloy:focus-parent element))
       (loop for cur = (alloy:focus-parent element) then (alloy:focus-parent cur)
             do (assert (eql :weak (alloy:focus cur)) ()
                        "Invariant violated: not all ancestors of a ~a are weakly focused.~%~a"
                        element
                        (with-output-to-string (out) (print-focus-tree tree out)))
             until (eql cur (alloy:focus-parent cur)))))
    (:weak
     (assert (or (eql :strong (alloy:focus (alloy:focus-parent element)))
                 (find-child-with :strong element)) ()
                 "Invariant violated: neither direct parent nor any successor of a ~a are strongly focused.~%~a"
                 element
                 (with-output-to-string (out) (print-focus-tree tree out))))
    ((NIL))))

(defun check-tree-invariant (tree)
  (assert (eq :strong (alloy:focus (alloy:focused tree))) ()
          "Invariant violated: root points to ~a which is not strongly focused, while ~a is.~%~a"
          (alloy:focused tree)
          (or (find-child-with :strong (alloy:root tree)) "no element")
          (with-output-to-string (out) (print-focus-tree tree out)))
  (labels ((recurse (element)
             (check-focus-invariant tree element)
             (alloy:do-elements (child element)
               (recurse child))))
    (recurse (alloy:root tree))))

(defun print-focus-tree (tree &optional (stream *standard-output*))
  (labels ((recurse (element depth)
             (format stream "~&~v{  ~}- ~a ~a~@[ ^~]~%" depth 0 (name element) (alloy:focus element) (eq element (alloy:focused tree)))
             (alloy:do-elements (child element)
               (recurse child (1+ depth)))))
    (recurse (alloy:root tree) 0)))

(defun compose-tree (structure)
  (let* ((tree (make-instance 'alloy:focus-tree))
         (root (make-instance 'named-focus-list :name 'root :focus-parent tree))
         (els ()))
    (labels ((mk (parent name)
               (push (make-instance 'named-focus-list :name name :parent parent) els))
             (build (parent children)
               (loop for child in children
                     do (if (listp child)
                            (build (mk parent (first child)) (rest child))
                            (mk parent child)))))
      (mk root structure)
      (values tree els))))

(defun random-tree ()
  (let* ((tree (make-instance 'alloy:focus-tree))
         (root (make-instance 'named-focus-list :name 'root :focus-parent tree))
         (els (list root)))
    (loop for i from 1 to 10
          for parent = (alexandria:random-elt els)
          for child = (make-instance 'named-focus-list :focus-parent parent :name
                                     (format NIL "~a-~a" (name parent) i))
          do (push child els))
    (values tree els)))

(define-test focus-tree
  :parent alloy)

(define-test focus-root
  :parent focus-tree
  (let ((tree (make-instance 'alloy:focus-tree)))
    (is eq NIL (alloy:root tree))
    (is eq NIL (alloy:focused tree))
    (let ((el (make-instance 'alloy:focus-element :focus-parent tree)))
      (is eq el (alloy:root tree))
      (is eq el (alloy:focused tree))
      (is eq tree (alloy:focus-tree el))
      (is eq el (alloy:focus-parent el))
      (is eq :strong (alloy:focus el)))))

(define-test focus-root-invariant
  :parent focus-tree
  :depends-on (focus-root)
  (let* ((tree (make-instance 'alloy:focus-tree))
         (el (make-instance 'alloy:focus-element :focus-parent tree)))
    (fail (make-instance 'alloy:focus-element :focus-parent tree))
    (is eq el (alloy:exit el))
    (is eq el (alloy:root tree))
    (is eq :strong (alloy:focus el))))

(define-test focus-list
  :parent focus-tree
  :depends-on (focus-root))

(define-test empty-focus-list
  :parent focus-list
  (let* ((tree (make-instance 'alloy:focus-tree))
         (list (make-instance 'alloy:focus-list :focus-parent tree)))
    (is eq NIL (alloy:focused list))
    (is eq NIL (alloy:focus-next list))
    (is eq NIL (alloy:focus-prev list))
    (fail (setf (alloy:index list) 0))
    (is eq list (alloy:activate list))))

(define-test one-level-focus-list
  :parent focus-list
  :depends-on (empty-focus-list vector-container)
  (let* ((tree (make-instance 'alloy:focus-tree))
         (list (make-instance 'alloy:focus-list :focus-parent tree))
         (e1 (make-instance 'alloy:focus-element :focus-parent list))
         (e2 (make-instance 'alloy:focus-element :focus-parent list))
         (e3 (make-instance 'alloy:focus-element :focus-parent list)))
    (is eq list (alloy:focus-parent e1))
    (is eq list (alloy:focus-parent e2))
    (is eq list (alloy:focus-parent e3))
    (is eq tree (alloy:focus-tree e1))
    (is eq tree (alloy:focus-tree e2))
    (is eq tree (alloy:focus-tree e3))
    (is eq NIL (alloy:focus e1))
    (is eq NIL (alloy:focus e2))
    (is eq NIL (alloy:focus e3))
    (is eq NIL (alloy:focused list))
    (alloy:activate list)
    (is eq :strong (alloy:focus list))
    (group (weak-focus-cycling)
      (is eq e1 (alloy:focus-next list))
      (is eq e1 (alloy:focused list))
      (is eq :strong (alloy:focus list))
      (is eq :weak (alloy:focus e1))
      (is eq NIL (alloy:focus e2))
      (is eq NIL (alloy:focus e3))
      (is eq e2 (alloy:focus-next list))
      (is eq e2 (alloy:focused list))
      (is eq NIL (alloy:focus e1))
      (is eq :strong (alloy:focus list))
      (is eq :weak (alloy:focus e2))
      (is eq NIL (alloy:focus e3))
      (is eq e3 (alloy:focus-next list))
      (is eq e3 (alloy:focused list))
      (is eq NIL (alloy:focus e1))
      (is eq NIL (alloy:focus e2))
      (is eq :strong (alloy:focus list))
      (is eq :weak (alloy:focus e3))
      (is eq e1 (alloy:focus-next list))
      (is eq e1 (alloy:focused list))
      (is eq :strong (alloy:focus list))
      (is eq :weak (alloy:focus e1))
      (is eq NIL (alloy:focus e2))
      (is eq NIL (alloy:focus e3))
      (is eq list (alloy:focused tree)))
    (group (inner-focus-passing)
      (is eq e1 (alloy:activate list))
      (is eq e1 (alloy:focused list))
      (is eq :strong (alloy:focus e1))
      (is eq e1 (alloy:focused tree))
      (is eq list (alloy:exit e1))
      (is eq :weak (alloy:focus e1))
      (is eq e1 (alloy:focused list))
      (is eq list (alloy:focused tree))
      (is eq :strong (alloy:focus list)))
    (group (focus-stealing)
      (is eq e1 (alloy:activate list))
      (is eq e3 (alloy:activate e3))
      (is eq :strong (alloy:focus e3))
      (is eq e3 (alloy:focused tree))
      (is eq e3 (alloy:focused list))
      (is eq NIL (alloy:focus e1))
      (is eq list (setf (alloy:focused tree) list))
      (is eq :strong (alloy:focus list))
      (is eq :weak (alloy:focus e3))
      (is eq e3 (alloy:focused list)))
    (group (index-checks)
      (is = 0 (alloy:element-index e1 list))
      (is = 1 (alloy:element-index e2 list))
      (is = 2 (alloy:element-index e3 list))
      (is = 2 (alloy:index list)))
    (group (index-focus-stealing)
      (is = 0 (setf (alloy:index list) 0))
      (is eq e1 (alloy:focused list))
      (is eq :weak (alloy:focus e1))
      (is eq NIL (alloy:focus e3))
      (is eq :strong (alloy:focus list))
      (is eq list (alloy:focused tree)))
    (group (index-update)
      (is eq e1 (alloy:update e1 list :index 1))
      (is = 1 (alloy:element-index e1 list))
      (is = 0 (alloy:element-index e2 list))
      (is = 2 (alloy:element-index e3 list))
      (is = 1 (alloy:index list))
      (is eq e1 (alloy:focused list)))))

(define-test multi-level-focus-list
  :parent focus-list
  :depends-on (one-level-focus-list)
  (let* ((tree (make-instance 'alloy:focus-tree))
         (root (make-instance 'alloy:focus-list :focus-parent tree))
         (e1 (make-instance 'alloy:focus-element :focus-parent root))
         (e2 (make-instance 'alloy:focus-list :focus-parent root))
         (e2e1 (make-instance 'alloy:focus-element :focus-parent e2))
         (e2e2 (make-instance 'alloy:focus-element :focus-parent e2))
         (e3 (make-instance 'alloy:focus-list :focus-parent root))
         (e3e1 (make-instance 'alloy:focus-list :focus-parent e3))
         (e3e1e1 (make-instance 'alloy:focus-element :focus-parent e3e1)))
    (is eq tree (alloy:focus-tree e1))
    (is eq tree (alloy:focus-tree e2))
    (is eq tree (alloy:focus-tree e2e1))
    (is eq tree (alloy:focus-tree e2e2))
    (is eq tree (alloy:focus-tree e3))
    (is eq tree (alloy:focus-tree e3e1))
    (is eq tree (alloy:focus-tree e3e1e1))
    (group (simple-focus-movement)
      (group (focus-e2)
        (is eq e2 (alloy:activate e2))
        (is eq e2 (alloy:focused tree))
        (is eq e2 (alloy:focused root))
        (is eq NIL (alloy:focus e1))
        (is eq :strong (alloy:focus e2))
        (is eq NIL (alloy:focus e3)))
      (group (focus-next)
        (is eq e2e1 (alloy:focus-next e2))
        (is eq e2e1 (alloy:focused e2))
        (is eq :strong (alloy:focus e2))
        (is eq :weak (alloy:focus e2e1)))
      (group (focus-selected)
        (is eq e2e1 (alloy:activate e2))
        (is eq e2e1 (alloy:focused tree))
        (is eq :weak (alloy:focus e2))
        (is eq :strong (alloy:focus e2e1)))
      (group (exit-1)
        (is eq e2 (alloy:exit e2e1))
        (is eq e2 (alloy:focused tree))
        (is eq :strong (alloy:focus e2))
        (is eq :weak (alloy:focus e2e1)))
      (group (exit-2)
        (is eq root (alloy:exit e2))
        (is eq :weak (alloy:focus e2))
        (is eq NIL (alloy:focus e2e1)))
      (group (focus-e2e2)
        (is eq e2e2 (alloy:activate e2e2))
        (is eq e2e2 (alloy:focused tree))
        (is eq e2e2 (alloy:focused e2))
        (is eq e2 (alloy:focused root))
        (is eq :weak (alloy:focus e2))
        (is eq NIL (alloy:focus e2e1))
        (is eq :strong (alloy:focus e2e2))))
    (group (deep-focus-stealing)
      (is eq e3e1e1 (alloy:activate e3e1e1))
      (is eq e3e1e1 (alloy:focused tree))
      (is eq NIL (alloy:focus e1))
      (is eq NIL (alloy:focus e2))
      (is eq NIL (alloy:focus e2e1))
      (is eq NIL (alloy:focus e2e2))
      (is eq :weak (alloy:focus e3))
      (is eq :weak (alloy:focus e3e1))
      (is eq :strong (alloy:focus e3e1e1))
      (is eq e3 (alloy:focused root))
      (is eq e3e1 (alloy:focused e3))
      (is eq e3e1e1 (alloy:focused e3e1)))))

(define-test leaf-tree-updates
  :parent focus-list
  :depends-on (one-level-focus-list)
  (let* ((tree (make-instance 'alloy:focus-tree))
         (root (make-instance 'alloy:focus-list :focus-parent tree))
         (e1 (make-instance 'alloy:focus-element :focus-parent root)))
    (is eq root (alloy:focus-parent e1))
    (is eq tree (alloy:focus-tree e1))
    (is eq root (alloy:focused tree))
    ;; Leave e1
    (finish (alloy:leave e1 T))
    (fail (alloy:leave e1 root))
    (is eq NIL (alloy:focus-tree e1))
    (fail (alloy:focus-parent e1))
    (is eq root (alloy:focused tree))
    ;; Re-enter e1
    (finish (alloy:enter e1 root))
    (is eq root (alloy:focus-parent e1))
    (is eq tree (alloy:focus-tree e1))
    ;; Focus e1
    (finish (alloy:activate e1))
    (is eq e1 (alloy:focused tree))
    (is eq :strong (alloy:focus e1))
    ;; Leave e1
    (finish (alloy:leave e1 T))
    (is eq NIL (alloy:focus-tree e1))
    (fail (alloy:focus-parent e1))
    (is eq NIL (alloy:focus e1))
    (is eq root (alloy:focused tree))))

(define-test multi-level-tree-updates
  :parent focus-list
  :depends-on (leaf-tree-updates multi-level-focus-list)
  (let* ((tree (make-instance 'alloy:focus-tree))
         (root (make-instance 'alloy:focus-list :focus-parent tree))
         (e1 (make-instance 'alloy:focus-list :focus-parent root))
         (e1e1 (make-instance 'alloy:focus-element :focus-parent e1)))
    (is eq tree (alloy:focus-tree e1e1))
    (group (leave-e1)
      (finish (alloy:leave e1 T))
      (fail (alloy:leave e1 root))
      (is eq NIL (alloy:focus-tree e1))
      (is eq NIL (alloy:focus-tree e1e1))
      (fail (alloy:focus-parent e1))
      (is eq e1 (alloy:focus-parent e1e1)))
    (group (re-enter-e1)
      (finish (alloy:enter e1 root))
      (is eq root (alloy:focus-parent e1))
      (is eq e1 (alloy:focus-parent e1e1))
      (is eq tree (alloy:focus-tree e1))
      (is eq tree (alloy:focus-tree e1e1)))
    (group (focus-e1e1)
      (finish (alloy:activate e1e1))
      (is eq e1e1 (alloy:focused tree))
      (is eq :strong (alloy:focus e1e1)))
    (group (leave-e1)
      (finish (alloy:leave e1 T))
      (is eq NIL (alloy:focus e1e1))
      (is eq NIL (alloy:focus e1))
      (is eq root (alloy:focused tree)))
    (group (re-enter-e1)
      (finish (alloy:enter e1 root))
      (finish (alloy:activate e1e1)))
    (group (leave-e1e1)
      (finish (alloy:leave e1e1 T))
      (is eq NIL (alloy:focus e1e1))
      (is eq :strong (alloy:focus e1))
      (is eq e1 (alloy:focused tree)))))

(define-test tree-invariant
  :parent focus-list
  :depends-on (multi-level-tree-updates)
  (loop repeat 10
        do (multiple-value-bind (tree els) (random-tree)
             (loop for name in (loop repeat 100 collect (name (alexandria:random-elt els)))
                   for random = (find name els :key #'name)
                   do (alloy:activate random)
                      (finish (check-tree-invariant tree))))))

;; TODO: Write a randomised test suite that checks invariants such as:
;;       - The focus-tree must be the same across the entire tree
;;       - There can only be one strongly focused element
;;       - If an element is strongly focused it is pointed to by the FOCUSED pointer from the tree
;;       - If an element is not part of a tree, its focus-tree must be unset
;;       - An element can only be weakly focused if:
;;         - A child at some depth is strongly focused
;;         - The immediate parent is strongly focused
;;       - If the parent is strongly focused there can only be one weakly focused child
;;       - If an element is strongly focused, all of its parents must be weakly focused.
;;       etc.
